type ChunkProps = {
    text: string[];
    audio: {
        mimeType: string;
        data: string[];
    };
    functionCall?: FunctionCall;
    executableCode?: {
        language: string;
        code: string;
    };
};
type NonRealtimeInput = {
    prompt: string;
    role?: "user" | "gemini";
};
type Response = {
    type: "text" | "audio" | "function";
    role: "gemini";
    text?: string;
    audio?: {
        mimeType: string;
        data: string;
    };
    functionCall?: FunctionCall;
    executableCode?: {
        language: string;
        code: string;
    };
};
type GeminiConfig = {
    generationConfig?: {
        maxOutputTokens?: number;
        temperature?: number;
        topP?: number;
        topK?: number;
        responseType?: "TEXT" | "AUDIO";
        voiceName?: "Aoede" | "Charon" | "Fenrir" | "Kore" | "Puck";
    };
    systemInstruction?: string;
    tools?: ToolsConfig;
    safetySettings?: Record<string, {
        category: HarmCategory;
        threshold: HarmBlockThreshold;
    }>[];
};
type ConnectionCloseReason = {
    code: number;
    trace_id?: string;
    reason: string;
};
type SocketResponse = {
    turnComplete?: boolean;
    modelTurn?: {
        parts: {
            text?: string;
            inlineData?: {
                mimeType: string;
                data: string;
            };
            executableCode?: {
                language: string;
                code: string;
            };
        }[];
    };
};
type ToolCallSocketResponse = {
    functionCalls: FunctionCall[];
};
type FunctionCall = {
    name: string;
    args: Record<string, any>;
    id: string;
};
type ParameterSchema = {
    type: ParameterType;
    format?: string;
    description?: string;
    nullable?: boolean;
    enum?: string[];
    maxItems?: number;
    minItems?: number;
    properties?: Record<string, ParameterSchema>;
    required?: string[];
    items?: Record<string, ParameterSchema>;
};
type FunctionDeclaration = {
    name: string;
    description: string;
    parameters?: ParameterSchema;
};
type GoogleSearchRetrieval = {
    dynamicRetrievalConfig: {
        mode: DynamicRetrievalMode;
        dynamicThreshold: number;
    };
};
type ToolsConfig = {
    functionDeclarations?: FunctionDeclaration[];
    googleSearchRetrieval?: GoogleSearchRetrieval;
};
declare enum ParameterType {
    UNSPECIFIED = "TYPE_UNSPECIFIED",
    STRING = "STRING",
    NUMBER = "NUMBER",
    INTEGER = "INTEGER",
    BOOLEAN = "BOOLEAN",
    ARRAY = "ARRAY",
    OBJECT = "OBJECT"
}
declare enum DynamicRetrievalMode {
    UNSPECIFIED = "MODE_UNSPECIFIED",
    DYNAMIC = "MODE_DYNAMIC"
}
declare enum HarmCategory {
    UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED",
    DEROGATORY = "HARM_CATEGORY_DEROGATORY",
    TOXICITY = "HARM_CATEGORY_TOXICITY",
    VIOLENCE = "HARM_CATEGORY_VIOLENCE",
    SEXUAL = "HARM_CATEGORY_SEXUAL",
    MEDICAL = "HARM_CATEGORY_MEDICAL",
    DANGEROUS = "HARM_CATEGORY_DANGEROUS",
    HARASSMENT = "HARM_CATEGORY_HARASSMENT",
    HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH",
    SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
    DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT",
    CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY"
}
declare enum HarmBlockThreshold {
    UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
    LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE",
    MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE",
    ONLY_HIGH = "BLOCK_ONLY_HIGH",
    NONE = "BLOCK_NONE",
    OFF = "OFF"
}

export { type ChunkProps, type ConnectionCloseReason, DynamicRetrievalMode, type FunctionCall, type FunctionDeclaration, type GeminiConfig, type GoogleSearchRetrieval, HarmBlockThreshold, HarmCategory, type NonRealtimeInput, type ParameterSchema, ParameterType, type Response, type SocketResponse, type ToolCallSocketResponse, type ToolsConfig };
