import { Writable } from 'stream';
import { GeminiConfig, NonRealtimeInput, Response, ConnectionCloseReason } from '../@types/index.mjs';

/**
 * GeminiLive class for handling real-time communication with the Gemini API
 */
declare class GeminiLive {
    #private;
    /**
     * Creates a new GeminiLive instance
     * @param {string} api_token - The API token for authentication
     * @param {GeminiConfig} [generation_config] - Optional configuration for the Gemini model
     * @throws {TypeError} If api_token is not a string
     * @throws {ReferenceError} If api_token is empty
     */
    constructor(api_token: string, generation_config?: GeminiConfig);
    /**
     * Gets the writable stream for sending audio data
     * @returns {Promise<Writable>} A promise that resolves to a Writable stream
     */
    get_writable_stream(): Promise<Writable>;
    /**
     * Sends a message to the Gemini API and waits for a response
     * @param {NonRealtimeInput[] | { prompt: string }} input - The input message(s) to send
     * @param {number} [timeout=15000] - Timeout in milliseconds for the request
     * @returns {Promise<Response>} A promise that resolves to the API response
     * @throws {Error} If the input is invalid, connection fails, or request times out
     */
    send(input: NonRealtimeInput[] | {
        prompt: string;
    }, timeout?: number): Promise<Response>;
    /**
     * Initiates real-time communication with the Gemini API
     * @param {(response: Response) => void} on_stream_response - Callback function for handling stream responses
     * @param {Buffer} [audio_input] - Optional audio input buffer
     * @throws {Error} If WebSocket connection fails or parameters are invalid
     */
    realtime(on_stream_response: (reponse: Response) => void, audio_input?: Buffer): void;
    /**
     * Sets up a callback for when the connection handshake is complete
     * @param {() => void} callbackfn - The callback function to execute
     * @returns {this} The current instance for method chaining
     */
    on_handshake(callbackfn: () => void): this;
    /**
     * Sets up a callback for when the connection is opened
     * @param {() => void} callbackfn - The callback function to execute
     * @returns {this} The current instance for method chaining
     */
    on_open(callbackfn: () => void): this;
    /**
     * Sets up a callback for when the connection is closed
     * @param {(reason: ConnectionCloseReason) => void} callbackfn - The callback function to execute
     * @returns {this} The current instance for method chaining
     */
    on_close(callbackfn: (reason: ConnectionCloseReason) => void): this;
}

export { GeminiLive };
